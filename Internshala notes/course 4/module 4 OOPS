const user={
    name:{
        first:"alok",
        last:"Jha"
    },
    property:function (){
        console.log("this is a func");
    }
}

// user["name"]["first"]="keshav"; changed the value at 
// nested loop 

// user.newFunc=function (){
//     console.log("this is an added function");
// } you can add new function into an object as well 


// console.log(typeof {})
// console.log(user);

// abstraction exmple

// class Animal{
//      sound(){
//          throw new Error("Method sound() should be overriden");  
        // we throw error cause the dog subclass could 
        // forget to call the sound() and since we dont have
        // abstract keyword here. it wont throw error otherwise.
        
//      }
// }

// class Dog extends Animal{
   
//      sound(){
//         console.log("dog barks");
//     }
    
// }

// const  d1=new Dog();
// d1.sound();


function BankAccount(owner, balance) {
  let _balance = balance; // private variable

  this.owner = owner;

  this.deposit = function(amount) {
    _balance += amount;
    console.log(`Deposited ${amount}.`);
  };

  this.getBalance = function() {
    return _balance; // controlled access
  };
}

const account = new BankAccount("Harshita", 1000);
account.deposit(500);         // Deposited 500
console.log(account.getBalance()); // 1500
console.log(account._balance); 



class Customer{
    constructor(name,email){
        this.email=email; 
        this.name=name;
            }
// constructor are special functions that executes automatically
// when we want to create an object or instance using new 
// keyword 

// this.name creates a local variable inside the class by itself
// we don't have to explicitly create it and let name (not needed)
    
    get info(){
        return this.name;
    }

// we use get to make info like a property of object and 
// not like a function hence (customer1.info) without brackets
// this is helpful when we want complex functions to look 
// like an object properties.
    
    details(){
        console.log(`this is ${this.name} and emai is ${this.email}`)
    }
}

// const customer1=new Customer("alok","alokjha@gmail");
// const customer2=new Customer("keshav","keshav@gmail");

// console.log(customer1);
// console.log(customer1.info);
// console.log(customer2);


class Vip extends Customer{
    
    constructor(name,email,viplevel){
        super(name,email);
        this.viplevel=viplevel;
    }
    
    
    UpdateViplevel(level){
      this.viplevel=level;
      return`vip level is ${this.viplevel}`;
    //   if I dont return and just console.log here, it will 
    // return the 
    }
}

const v1=new Vip("alok","alok@gmail",1);



// console.log(v1);
// console.log(v1.UpdateViplevel(3))



const obj1={
    first:"alok",
    last: "jha",
    property:function(){
        console.log(`welcome ${this.first} ${this.last}`);
    }
}


const obj2={
    first:"mark",
    last: "Zukerberg",
    
}

// obj1.property();
// obj1.property.call(obj2);
// these are call function where you can use 1 objects 
// function into other object's execution context and the 
// this keyword will refer to this new object's keys


let prop =  function(age,hobby){
    console.log(`this is a custom method ${this.first} and ${age} and my hobby is ${hobby}`);
} 
// we can call property using call and assign it to an object
// as well and pass other arguments next to it.



// prop.apply(obj1,[22,"badminton"]);
// use apply when the values are already in an array format
// like num=[1,2,4] just pass apply.(obj,num)


// let approve=prop.bind(obj1,[22,"badminton"]);
// console.log(approve);
// approve();  doesnt call the function immediately instead
// the this value automatically sets to what you have passed 



// this function is an example of all these three combined 
function createGreeting(firstName, lastName) {
    // Define person object with firstName and lastName properties
    const person = {
        firstName: firstName,
        lastName: lastName
    };
    
    
    
    // Define greet function within createGreeting
    function greet() {
        console.log(`Hello, ${this.firstName} ${this.lastName}!`);
    }
    
    // Use call to invoke greet with person context (callGreet)
     function callGreet() {
        greet.call(person);
     }
    // Use apply to invoke greet with person context and array of arguments (applyGreet)
    function applyGreet() {
        greet.apply(person);
    }
    // Use bind to create a bound function and assign it to bindGreet
    const bindGreet = greet.bind(person);
    
    callGreet();
    applyGreet();
    bindGreet();
}

// createGreeting("John", "Doe");


// const obj={
//     x: 10,
//     y:() => {
//         console.log(this);
//     }
// }

// obj.y();

// arrow function doesnt have their own this and they 
// simply inherit it from their lexical scope and in this case
// its their global scope which is undefined in nodejs case
// and window object in browser case. 

// const obj={
//     x: 10,
//     z: function() {
//         const y= () => {
//         console.log(this);
//     }
//     y();
//     }
// }

// obj.z();  output:{ x: 10, z: [Function: z] }
// as you can see in the output y() takes z's parent which is
// obj as its lexical inheritance. 

function createCounter() {
  // Define counterObj with count property
  const counterObj = { count: 0 };
  // Define increment arrow function within createCounter
  counterObj.increment = function() {
    counterObj.count++;
    console.log(this.count);
  };
  // Return the increment function
  return counterObj;
}
const counter = createCounter();
counter.increment();
counter.increment();

























